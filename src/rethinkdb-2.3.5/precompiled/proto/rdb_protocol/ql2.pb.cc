// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rdb_protocol/ql2.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "rdb_protocol/ql2.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* VersionDummy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VersionDummy_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* VersionDummy_Version_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* VersionDummy_Protocol_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Query_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Query_reflection_ = NULL;
const ::google::protobuf::Descriptor* Query_AssocPair_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Query_AssocPair_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Query_QueryType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Frame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Frame_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Frame_FrameType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Backtrace_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Backtrace_reflection_ = NULL;
const ::google::protobuf::Descriptor* Response_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Response_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Response_ResponseType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Response_ErrorType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Response_ResponseNote_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Datum_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Datum_reflection_ = NULL;
const ::google::protobuf::Descriptor* Datum_AssocPair_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Datum_AssocPair_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Datum_DatumType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Term_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Term_reflection_ = NULL;
const ::google::protobuf::Descriptor* Term_AssocPair_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Term_AssocPair_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Term_TermType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto() {
  protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "rdb_protocol/ql2.proto");
  GOOGLE_CHECK(file != NULL);
  VersionDummy_descriptor_ = file->message_type(0);
  static const int VersionDummy_offsets_[1] = {
  };
  VersionDummy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VersionDummy_descriptor_,
      VersionDummy::default_instance_,
      VersionDummy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionDummy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionDummy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VersionDummy));
  VersionDummy_Version_descriptor_ = VersionDummy_descriptor_->enum_type(0);
  VersionDummy_Protocol_descriptor_ = VersionDummy_descriptor_->enum_type(1);
  Query_descriptor_ = file->message_type(1);
  static const int Query_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, query_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, token_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, obsolete_noreply_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, accepts_r_json_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, global_optargs_),
  };
  Query_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Query_descriptor_,
      Query::default_instance_,
      Query_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Query));
  Query_AssocPair_descriptor_ = Query_descriptor_->nested_type(0);
  static const int Query_AssocPair_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query_AssocPair, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query_AssocPair, val_),
  };
  Query_AssocPair_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Query_AssocPair_descriptor_,
      Query_AssocPair::default_instance_,
      Query_AssocPair_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query_AssocPair, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query_AssocPair, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Query_AssocPair));
  Query_QueryType_descriptor_ = Query_descriptor_->enum_type(0);
  Frame_descriptor_ = file->message_type(2);
  static const int Frame_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, opt_),
  };
  Frame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Frame_descriptor_,
      Frame::default_instance_,
      Frame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Frame));
  Frame_FrameType_descriptor_ = Frame_descriptor_->enum_type(0);
  Backtrace_descriptor_ = file->message_type(3);
  static const int Backtrace_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Backtrace, frames_),
  };
  Backtrace_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Backtrace_descriptor_,
      Backtrace::default_instance_,
      Backtrace_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Backtrace, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Backtrace, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Backtrace));
  Response_descriptor_ = file->message_type(4);
  static const int Response_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, error_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, notes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, token_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, response_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, backtrace_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, profile_),
  };
  Response_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Response_descriptor_,
      Response::default_instance_,
      Response_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Response));
  Response_ResponseType_descriptor_ = Response_descriptor_->enum_type(0);
  Response_ErrorType_descriptor_ = Response_descriptor_->enum_type(1);
  Response_ResponseNote_descriptor_ = Response_descriptor_->enum_type(2);
  Datum_descriptor_ = file->message_type(5);
  static const int Datum_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, r_bool_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, r_num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, r_str_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, r_array_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, r_object_),
  };
  Datum_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Datum_descriptor_,
      Datum::default_instance_,
      Datum_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Datum));
  Datum_AssocPair_descriptor_ = Datum_descriptor_->nested_type(0);
  static const int Datum_AssocPair_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum_AssocPair, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum_AssocPair, val_),
  };
  Datum_AssocPair_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Datum_AssocPair_descriptor_,
      Datum_AssocPair::default_instance_,
      Datum_AssocPair_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum_AssocPair, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum_AssocPair, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Datum_AssocPair));
  Datum_DatumType_descriptor_ = Datum_descriptor_->enum_type(0);
  Term_descriptor_ = file->message_type(6);
  static const int Term_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term, datum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term, args_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term, optargs_),
  };
  Term_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Term_descriptor_,
      Term::default_instance_,
      Term_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Term));
  Term_AssocPair_descriptor_ = Term_descriptor_->nested_type(0);
  static const int Term_AssocPair_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term_AssocPair, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term_AssocPair, val_),
  };
  Term_AssocPair_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Term_AssocPair_descriptor_,
      Term_AssocPair::default_instance_,
      Term_AssocPair_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term_AssocPair, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term_AssocPair, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Term_AssocPair));
  Term_TermType_descriptor_ = Term_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_rdb_5fprotocol_2fql2_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VersionDummy_descriptor_, &VersionDummy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Query_descriptor_, &Query::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Query_AssocPair_descriptor_, &Query_AssocPair::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Frame_descriptor_, &Frame::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Backtrace_descriptor_, &Backtrace::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Response_descriptor_, &Response::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Datum_descriptor_, &Datum::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Datum_AssocPair_descriptor_, &Datum_AssocPair::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Term_descriptor_, &Term::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Term_AssocPair_descriptor_, &Term_AssocPair::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto() {
  delete VersionDummy::default_instance_;
  delete VersionDummy_reflection_;
  delete Query::default_instance_;
  delete Query_reflection_;
  delete Query_AssocPair::default_instance_;
  delete Query_AssocPair_reflection_;
  delete Frame::default_instance_;
  delete Frame_reflection_;
  delete Backtrace::default_instance_;
  delete Backtrace_reflection_;
  delete Response::default_instance_;
  delete Response_reflection_;
  delete Datum::default_instance_;
  delete Datum_reflection_;
  delete Datum_AssocPair::default_instance_;
  delete Datum_AssocPair_reflection_;
  delete Term::default_instance_;
  delete Term_reflection_;
  delete Term_AssocPair::default_instance_;
  delete Term_AssocPair_reflection_;
}

void protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\026rdb_protocol/ql2.proto\"\213\001\n\014VersionDumm"
    "y\"O\n\007Version\022\014\n\004V0_1\020\266\364\206\373\003\022\014\n\004V0_2\020\341\203\302\221\007"
    "\022\014\n\004V0_3\020\276\320\327\373\005\022\014\n\004V0_4\020\240\332\260\200\004\022\014\n\004V1_0\020\303\373\212"
    "\246\003\"*\n\010Protocol\022\020\n\010PROTOBUF\020\301\370\377\270\002\022\014\n\004JSON"
    "\020\307\341\245\363\007\"\267\002\n\005Query\022\036\n\004type\030\001 \001(\0162\020.Query.Q"
    "ueryType\022\024\n\005query\030\002 \001(\0132\005.Term\022\r\n\005token\030"
    "\003 \001(\003\022\037\n\020OBSOLETE_noreply\030\004 \001(\010:\005false\022\035"
    "\n\016accepts_r_json\030\005 \001(\010:\005false\022(\n\016global_"
    "optargs\030\006 \003(\0132\020.Query.AssocPair\032,\n\tAssoc"
    "Pair\022\013\n\003key\030\001 \001(\t\022\022\n\003val\030\002 \001(\0132\005.Term\"Q\n"
    "\tQueryType\022\t\n\005START\020\001\022\014\n\010CONTINUE\020\002\022\010\n\004S"
    "TOP\020\003\022\020\n\014NOREPLY_WAIT\020\004\022\017\n\013SERVER_INFO\020\005"
    "\"`\n\005Frame\022\036\n\004type\030\001 \001(\0162\020.Frame.FrameTyp"
    "e\022\013\n\003pos\030\002 \001(\003\022\013\n\003opt\030\003 \001(\t\"\035\n\tFrameType"
    "\022\007\n\003POS\020\001\022\007\n\003OPT\020\002\"#\n\tBacktrace\022\026\n\006frame"
    "s\030\001 \003(\0132\006.Frame\"\254\005\n\010Response\022$\n\004type\030\001 \001"
    "(\0162\026.Response.ResponseType\022\'\n\nerror_type"
    "\030\007 \001(\0162\023.Response.ErrorType\022%\n\005notes\030\006 \003"
    "(\0162\026.Response.ResponseNote\022\r\n\005token\030\002 \001("
    "\003\022\030\n\010response\030\003 \003(\0132\006.Datum\022\035\n\tbacktrace"
    "\030\004 \001(\0132\n.Backtrace\022\027\n\007profile\030\005 \001(\0132\006.Da"
    "tum\"\247\001\n\014ResponseType\022\020\n\014SUCCESS_ATOM\020\001\022\024"
    "\n\020SUCCESS_SEQUENCE\020\002\022\023\n\017SUCCESS_PARTIAL\020"
    "\003\022\021\n\rWAIT_COMPLETE\020\004\022\017\n\013SERVER_INFO\020\005\022\020\n"
    "\014CLIENT_ERROR\020\020\022\021\n\rCOMPILE_ERROR\020\021\022\021\n\rRU"
    "NTIME_ERROR\020\022\"\254\001\n\tErrorType\022\016\n\010INTERNAL\020"
    "\300\204=\022\024\n\016RESOURCE_LIMIT\020\200\211z\022\022\n\013QUERY_LOGIC"
    "\020\300\215\267\001\022\024\n\rNON_EXISTENCE\020\340\232\275\001\022\020\n\tOP_FAILED"
    "\020\240\237\372\001\022\027\n\020OP_INDETERMINATE\020\300\254\200\002\022\013\n\004USER\020\300"
    "\226\261\002\022\027\n\020PERMISSION_ERROR\020\200\233\356\002\"p\n\014Response"
    "Note\022\021\n\rSEQUENCE_FEED\020\001\022\r\n\tATOM_FEED\020\002\022\027"
    "\n\023ORDER_BY_LIMIT_FEED\020\003\022\020\n\014UNIONED_FEED\020"
    "\004\022\023\n\017INCLUDES_STATES\020\005\"\243\002\n\005Datum\022\036\n\004type"
    "\030\001 \001(\0162\020.Datum.DatumType\022\016\n\006r_bool\030\002 \001(\010"
    "\022\r\n\005r_num\030\003 \001(\001\022\r\n\005r_str\030\004 \001(\t\022\027\n\007r_arra"
    "y\030\005 \003(\0132\006.Datum\022\"\n\010r_object\030\006 \003(\0132\020.Datu"
    "m.AssocPair\032-\n\tAssocPair\022\013\n\003key\030\001 \001(\t\022\023\n"
    "\003val\030\002 \001(\0132\006.Datum\"`\n\tDatumType\022\n\n\006R_NUL"
    "L\020\001\022\n\n\006R_BOOL\020\002\022\t\n\005R_NUM\020\003\022\t\n\005R_STR\020\004\022\013\n"
    "\007R_ARRAY\020\005\022\014\n\010R_OBJECT\020\006\022\n\n\006R_JSON\020\007\"\303\023\n"
    "\004Term\022\034\n\004type\030\001 \001(\0162\016.Term.TermType\022\025\n\005d"
    "atum\030\002 \001(\0132\006.Datum\022\023\n\004args\030\003 \003(\0132\005.Term\022"
    " \n\007optargs\030\004 \003(\0132\017.Term.AssocPair\032,\n\tAss"
    "ocPair\022\013\n\003key\030\001 \001(\t\022\022\n\003val\030\002 \001(\0132\005.Term\""
    "\240\022\n\010TermType\022\t\n\005DATUM\020\001\022\016\n\nMAKE_ARRAY\020\002\022"
    "\014\n\010MAKE_OBJ\020\003\022\007\n\003VAR\020\n\022\016\n\nJAVASCRIPT\020\013\022\t"
    "\n\004UUID\020\251\001\022\t\n\004HTTP\020\231\001\022\t\n\005ERROR\020\014\022\020\n\014IMPLI"
    "CIT_VAR\020\r\022\006\n\002DB\020\016\022\t\n\005TABLE\020\017\022\007\n\003GET\020\020\022\013\n"
    "\007GET_ALL\020N\022\006\n\002EQ\020\021\022\006\n\002NE\020\022\022\006\n\002LT\020\023\022\006\n\002LE"
    "\020\024\022\006\n\002GT\020\025\022\006\n\002GE\020\026\022\007\n\003NOT\020\027\022\007\n\003ADD\020\030\022\007\n\003"
    "SUB\020\031\022\007\n\003MUL\020\032\022\007\n\003DIV\020\033\022\007\n\003MOD\020\034\022\n\n\005FLOO"
    "R\020\267\001\022\t\n\004CEIL\020\270\001\022\n\n\005ROUND\020\271\001\022\n\n\006APPEND\020\035\022"
    "\013\n\007PREPEND\020P\022\016\n\nDIFFERENCE\020_\022\016\n\nSET_INSE"
    "RT\020X\022\024\n\020SET_INTERSECTION\020Y\022\r\n\tSET_UNION\020"
    "Z\022\022\n\016SET_DIFFERENCE\020[\022\t\n\005SLICE\020\036\022\010\n\004SKIP"
    "\020F\022\t\n\005LIMIT\020G\022\016\n\nOFFSETS_OF\020W\022\014\n\010CONTAIN"
    "S\020]\022\r\n\tGET_FIELD\020\037\022\010\n\004KEYS\020^\022\013\n\006VALUES\020\272"
    "\001\022\013\n\006OBJECT\020\217\001\022\016\n\nHAS_FIELDS\020 \022\017\n\013WITH_F"
    "IELDS\020`\022\t\n\005PLUCK\020!\022\013\n\007WITHOUT\020\"\022\t\n\005MERGE"
    "\020#\022\026\n\022BETWEEN_DEPRECATED\020$\022\014\n\007BETWEEN\020\266\001"
    "\022\n\n\006REDUCE\020%\022\007\n\003MAP\020&\022\t\n\004FOLD\020\273\001\022\n\n\006FILT"
    "ER\020\'\022\016\n\nCONCAT_MAP\020(\022\014\n\010ORDER_BY\020)\022\014\n\010DI"
    "STINCT\020*\022\t\n\005COUNT\020+\022\014\n\010IS_EMPTY\020V\022\t\n\005UNI"
    "ON\020,\022\007\n\003NTH\020-\022\014\n\007BRACKET\020\252\001\022\016\n\nINNER_JOI"
    "N\0200\022\016\n\nOUTER_JOIN\0201\022\013\n\007EQ_JOIN\0202\022\007\n\003ZIP\020"
    "H\022\n\n\005RANGE\020\255\001\022\r\n\tINSERT_AT\020R\022\r\n\tDELETE_A"
    "T\020S\022\r\n\tCHANGE_AT\020T\022\r\n\tSPLICE_AT\020U\022\r\n\tCOE"
    "RCE_TO\0203\022\013\n\007TYPE_OF\0204\022\n\n\006UPDATE\0205\022\n\n\006DEL"
    "ETE\0206\022\013\n\007REPLACE\0207\022\n\n\006INSERT\0208\022\r\n\tDB_CRE"
    "ATE\0209\022\013\n\007DB_DROP\020:\022\013\n\007DB_LIST\020;\022\020\n\014TABLE"
    "_CREATE\020<\022\016\n\nTABLE_DROP\020=\022\016\n\nTABLE_LIST\020"
    ">\022\013\n\006CONFIG\020\256\001\022\013\n\006STATUS\020\257\001\022\t\n\004WAIT\020\261\001\022\020"
    "\n\013RECONFIGURE\020\260\001\022\016\n\tREBALANCE\020\263\001\022\t\n\004SYNC"
    "\020\212\001\022\n\n\005GRANT\020\274\001\022\020\n\014INDEX_CREATE\020K\022\016\n\nIND"
    "EX_DROP\020L\022\016\n\nINDEX_LIST\020M\022\021\n\014INDEX_STATU"
    "S\020\213\001\022\017\n\nINDEX_WAIT\020\214\001\022\021\n\014INDEX_RENAME\020\234\001"
    "\022\013\n\007FUNCALL\020@\022\n\n\006BRANCH\020A\022\006\n\002OR\020B\022\007\n\003AND"
    "\020C\022\014\n\010FOR_EACH\020D\022\010\n\004FUNC\020E\022\007\n\003ASC\020I\022\010\n\004D"
    "ESC\020J\022\010\n\004INFO\020O\022\t\n\005MATCH\020a\022\013\n\006UPCASE\020\215\001\022"
    "\r\n\010DOWNCASE\020\216\001\022\n\n\006SAMPLE\020Q\022\013\n\007DEFAULT\020\\\022"
    "\010\n\004JSON\020b\022\023\n\016TO_JSON_STRING\020\254\001\022\013\n\007ISO860"
    "1\020c\022\016\n\nTO_ISO8601\020d\022\016\n\nEPOCH_TIME\020e\022\021\n\rT"
    "O_EPOCH_TIME\020f\022\007\n\003NOW\020g\022\017\n\013IN_TIMEZONE\020h"
    "\022\n\n\006DURING\020i\022\010\n\004DATE\020j\022\017\n\013TIME_OF_DAY\020~\022"
    "\014\n\010TIMEZONE\020\177\022\t\n\004YEAR\020\200\001\022\n\n\005MONTH\020\201\001\022\010\n\003"
    "DAY\020\202\001\022\020\n\013DAY_OF_WEEK\020\203\001\022\020\n\013DAY_OF_YEAR\020"
    "\204\001\022\n\n\005HOURS\020\205\001\022\014\n\007MINUTES\020\206\001\022\014\n\007SECONDS\020"
    "\207\001\022\t\n\004TIME\020\210\001\022\n\n\006MONDAY\020k\022\013\n\007TUESDAY\020l\022\r"
    "\n\tWEDNESDAY\020m\022\014\n\010THURSDAY\020n\022\n\n\006FRIDAY\020o\022"
    "\014\n\010SATURDAY\020p\022\n\n\006SUNDAY\020q\022\013\n\007JANUARY\020r\022\014"
    "\n\010FEBRUARY\020s\022\t\n\005MARCH\020t\022\t\n\005APRIL\020u\022\007\n\003MA"
    "Y\020v\022\010\n\004JUNE\020w\022\010\n\004JULY\020x\022\n\n\006AUGUST\020y\022\r\n\tS"
    "EPTEMBER\020z\022\013\n\007OCTOBER\020{\022\014\n\010NOVEMBER\020|\022\014\n"
    "\010DECEMBER\020}\022\014\n\007LITERAL\020\211\001\022\n\n\005GROUP\020\220\001\022\010\n"
    "\003SUM\020\221\001\022\010\n\003AVG\020\222\001\022\010\n\003MIN\020\223\001\022\010\n\003MAX\020\224\001\022\n\n"
    "\005SPLIT\020\225\001\022\014\n\007UNGROUP\020\226\001\022\013\n\006RANDOM\020\227\001\022\014\n\007"
    "CHANGES\020\230\001\022\t\n\004ARGS\020\232\001\022\013\n\006BINARY\020\233\001\022\014\n\007GE"
    "OJSON\020\235\001\022\017\n\nTO_GEOJSON\020\236\001\022\n\n\005POINT\020\237\001\022\t\n"
    "\004LINE\020\240\001\022\014\n\007POLYGON\020\241\001\022\r\n\010DISTANCE\020\242\001\022\017\n"
    "\nINTERSECTS\020\243\001\022\r\n\010INCLUDES\020\244\001\022\013\n\006CIRCLE\020"
    "\245\001\022\025\n\020GET_INTERSECTING\020\246\001\022\t\n\004FILL\020\247\001\022\020\n\013"
    "GET_NEAREST\020\250\001\022\020\n\013POLYGON_SUB\020\253\001\022\013\n\006MINV"
    "AL\020\264\001\022\013\n\006MAXVAL\020\265\001", 4098);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "rdb_protocol/ql2.proto", &protobuf_RegisterTypes);
  VersionDummy::default_instance_ = new VersionDummy();
  Query::default_instance_ = new Query();
  Query_AssocPair::default_instance_ = new Query_AssocPair();
  Frame::default_instance_ = new Frame();
  Backtrace::default_instance_ = new Backtrace();
  Response::default_instance_ = new Response();
  Datum::default_instance_ = new Datum();
  Datum_AssocPair::default_instance_ = new Datum_AssocPair();
  Term::default_instance_ = new Term();
  Term_AssocPair::default_instance_ = new Term_AssocPair();
  VersionDummy::default_instance_->InitAsDefaultInstance();
  Query::default_instance_->InitAsDefaultInstance();
  Query_AssocPair::default_instance_->InitAsDefaultInstance();
  Frame::default_instance_->InitAsDefaultInstance();
  Backtrace::default_instance_->InitAsDefaultInstance();
  Response::default_instance_->InitAsDefaultInstance();
  Datum::default_instance_->InitAsDefaultInstance();
  Datum_AssocPair::default_instance_->InitAsDefaultInstance();
  Term::default_instance_->InitAsDefaultInstance();
  Term_AssocPair::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_rdb_5fprotocol_2fql2_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_rdb_5fprotocol_2fql2_2eproto {
  StaticDescriptorInitializer_rdb_5fprotocol_2fql2_2eproto() {
    protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  }
} static_descriptor_initializer_rdb_5fprotocol_2fql2_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* VersionDummy_Version_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VersionDummy_Version_descriptor_;
}
bool VersionDummy_Version_IsValid(int value) {
  switch(value) {
    case 885177795:
    case 1063369270:
    case 1074539808:
    case 1601562686:
    case 1915781601:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const VersionDummy_Version VersionDummy::V0_1;
const VersionDummy_Version VersionDummy::V0_2;
const VersionDummy_Version VersionDummy::V0_3;
const VersionDummy_Version VersionDummy::V0_4;
const VersionDummy_Version VersionDummy::V1_0;
const VersionDummy_Version VersionDummy::Version_MIN;
const VersionDummy_Version VersionDummy::Version_MAX;
const int VersionDummy::Version_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* VersionDummy_Protocol_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VersionDummy_Protocol_descriptor_;
}
bool VersionDummy_Protocol_IsValid(int value) {
  switch(value) {
    case 656407617:
    case 2120839367:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const VersionDummy_Protocol VersionDummy::PROTOBUF;
const VersionDummy_Protocol VersionDummy::JSON;
const VersionDummy_Protocol VersionDummy::Protocol_MIN;
const VersionDummy_Protocol VersionDummy::Protocol_MAX;
const int VersionDummy::Protocol_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
#endif  // !_MSC_VER

VersionDummy::VersionDummy()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VersionDummy::InitAsDefaultInstance() {
}

VersionDummy::VersionDummy(const VersionDummy& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VersionDummy::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VersionDummy::~VersionDummy() {
  SharedDtor();
}

void VersionDummy::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VersionDummy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VersionDummy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VersionDummy_descriptor_;
}

const VersionDummy& VersionDummy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  return *default_instance_;
}

VersionDummy* VersionDummy::default_instance_ = NULL;

VersionDummy* VersionDummy::New() const {
  return new VersionDummy;
}

void VersionDummy::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VersionDummy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void VersionDummy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VersionDummy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VersionDummy::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VersionDummy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VersionDummy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VersionDummy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VersionDummy::MergeFrom(const VersionDummy& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VersionDummy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VersionDummy::CopyFrom(const VersionDummy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VersionDummy::IsInitialized() const {

  return true;
}

void VersionDummy::Swap(VersionDummy* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VersionDummy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VersionDummy_descriptor_;
  metadata.reflection = VersionDummy_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Query_QueryType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Query_QueryType_descriptor_;
}
bool Query_QueryType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Query_QueryType Query::START;
const Query_QueryType Query::CONTINUE;
const Query_QueryType Query::STOP;
const Query_QueryType Query::NOREPLY_WAIT;
const Query_QueryType Query::SERVER_INFO;
const Query_QueryType Query::QueryType_MIN;
const Query_QueryType Query::QueryType_MAX;
const int Query::QueryType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Query_AssocPair::kKeyFieldNumber;
const int Query_AssocPair::kValFieldNumber;
#endif  // !_MSC_VER

Query_AssocPair::Query_AssocPair()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Query_AssocPair::InitAsDefaultInstance() {
  val_ = const_cast< ::Term*>(&::Term::default_instance());
}

Query_AssocPair::Query_AssocPair(const Query_AssocPair& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Query_AssocPair::SharedCtor() {
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  val_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Query_AssocPair::~Query_AssocPair() {
  SharedDtor();
}

void Query_AssocPair::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (this != default_instance_) {
    delete val_;
  }
}

void Query_AssocPair::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Query_AssocPair::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Query_AssocPair_descriptor_;
}

const Query_AssocPair& Query_AssocPair::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  return *default_instance_;
}

Query_AssocPair* Query_AssocPair::default_instance_ = NULL;

Query_AssocPair* Query_AssocPair::New() const {
  return new Query_AssocPair;
}

void Query_AssocPair::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
    if (has_val()) {
      if (val_ != NULL) val_->::Term::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Query_AssocPair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_val;
        break;
      }

      // optional .Term val = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_val:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_val()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Query_AssocPair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->key(), output);
  }

  // optional .Term val = 2;
  if (has_val()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->val(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Query_AssocPair::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }

  // optional .Term val = 2;
  if (has_val()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->val(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Query_AssocPair::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

    // optional .Term val = 2;
    if (has_val()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->val());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Query_AssocPair::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Query_AssocPair* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Query_AssocPair*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Query_AssocPair::MergeFrom(const Query_AssocPair& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_val()) {
      mutable_val()->::Term::MergeFrom(from.val());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Query_AssocPair::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Query_AssocPair::CopyFrom(const Query_AssocPair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Query_AssocPair::IsInitialized() const {

  return true;
}

void Query_AssocPair::Swap(Query_AssocPair* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(val_, other->val_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Query_AssocPair::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Query_AssocPair_descriptor_;
  metadata.reflection = Query_AssocPair_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Query::kTypeFieldNumber;
const int Query::kQueryFieldNumber;
const int Query::kTokenFieldNumber;
const int Query::kOBSOLETENoreplyFieldNumber;
const int Query::kAcceptsRJsonFieldNumber;
const int Query::kGlobalOptargsFieldNumber;
#endif  // !_MSC_VER

Query::Query()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Query::InitAsDefaultInstance() {
  query_ = const_cast< ::Term*>(&::Term::default_instance());
}

Query::Query(const Query& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Query::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  query_ = NULL;
  token_ = GOOGLE_LONGLONG(0);
  obsolete_noreply_ = false;
  accepts_r_json_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Query::~Query() {
  SharedDtor();
}

void Query::SharedDtor() {
  if (this != default_instance_) {
    delete query_;
  }
}

void Query::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Query::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Query_descriptor_;
}

const Query& Query::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  return *default_instance_;
}

Query* Query::default_instance_ = NULL;

Query* Query::New() const {
  return new Query;
}

void Query::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_query()) {
      if (query_ != NULL) query_->::Term::Clear();
    }
    token_ = GOOGLE_LONGLONG(0);
    obsolete_noreply_ = false;
    accepts_r_json_ = false;
  }
  global_optargs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Query::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Query.QueryType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Query_QueryType_IsValid(value)) {
            set_type(static_cast< ::Query_QueryType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_query;
        break;
      }

      // optional .Term query = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_query:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_query()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_token;
        break;
      }

      // optional int64 token = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_token:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &token_)));
          set_has_token();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_OBSOLETE_noreply;
        break;
      }

      // optional bool OBSOLETE_noreply = 4 [default = false];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_OBSOLETE_noreply:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &obsolete_noreply_)));
          set_has_obsolete_noreply();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_accepts_r_json;
        break;
      }

      // optional bool accepts_r_json = 5 [default = false];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_accepts_r_json:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &accepts_r_json_)));
          set_has_accepts_r_json();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_global_optargs;
        break;
      }

      // repeated .Query.AssocPair global_optargs = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_global_optargs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_global_optargs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_global_optargs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Query::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Query.QueryType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .Term query = 2;
  if (has_query()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->query(), output);
  }

  // optional int64 token = 3;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->token(), output);
  }

  // optional bool OBSOLETE_noreply = 4 [default = false];
  if (has_obsolete_noreply()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->obsolete_noreply(), output);
  }

  // optional bool accepts_r_json = 5 [default = false];
  if (has_accepts_r_json()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->accepts_r_json(), output);
  }

  // repeated .Query.AssocPair global_optargs = 6;
  for (int i = 0; i < this->global_optargs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->global_optargs(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Query::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Query.QueryType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .Term query = 2;
  if (has_query()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->query(), target);
  }

  // optional int64 token = 3;
  if (has_token()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->token(), target);
  }

  // optional bool OBSOLETE_noreply = 4 [default = false];
  if (has_obsolete_noreply()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->obsolete_noreply(), target);
  }

  // optional bool accepts_r_json = 5 [default = false];
  if (has_accepts_r_json()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->accepts_r_json(), target);
  }

  // repeated .Query.AssocPair global_optargs = 6;
  for (int i = 0; i < this->global_optargs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->global_optargs(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Query::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Query.QueryType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .Term query = 2;
    if (has_query()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->query());
    }

    // optional int64 token = 3;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->token());
    }

    // optional bool OBSOLETE_noreply = 4 [default = false];
    if (has_obsolete_noreply()) {
      total_size += 1 + 1;
    }

    // optional bool accepts_r_json = 5 [default = false];
    if (has_accepts_r_json()) {
      total_size += 1 + 1;
    }

  }
  // repeated .Query.AssocPair global_optargs = 6;
  total_size += 1 * this->global_optargs_size();
  for (int i = 0; i < this->global_optargs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->global_optargs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Query::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Query* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Query*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Query::MergeFrom(const Query& from) {
  GOOGLE_CHECK_NE(&from, this);
  global_optargs_.MergeFrom(from.global_optargs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_query()) {
      mutable_query()->::Term::MergeFrom(from.query());
    }
    if (from.has_token()) {
      set_token(from.token());
    }
    if (from.has_obsolete_noreply()) {
      set_obsolete_noreply(from.obsolete_noreply());
    }
    if (from.has_accepts_r_json()) {
      set_accepts_r_json(from.accepts_r_json());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Query::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Query::CopyFrom(const Query& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Query::IsInitialized() const {

  return true;
}

void Query::Swap(Query* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(query_, other->query_);
    std::swap(token_, other->token_);
    std::swap(obsolete_noreply_, other->obsolete_noreply_);
    std::swap(accepts_r_json_, other->accepts_r_json_);
    global_optargs_.Swap(&other->global_optargs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Query::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Query_descriptor_;
  metadata.reflection = Query_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Frame_FrameType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Frame_FrameType_descriptor_;
}
bool Frame_FrameType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Frame_FrameType Frame::POS;
const Frame_FrameType Frame::OPT;
const Frame_FrameType Frame::FrameType_MIN;
const Frame_FrameType Frame::FrameType_MAX;
const int Frame::FrameType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Frame::kTypeFieldNumber;
const int Frame::kPosFieldNumber;
const int Frame::kOptFieldNumber;
#endif  // !_MSC_VER

Frame::Frame()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Frame::InitAsDefaultInstance() {
}

Frame::Frame(const Frame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Frame::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  pos_ = GOOGLE_LONGLONG(0);
  opt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Frame::~Frame() {
  SharedDtor();
}

void Frame::SharedDtor() {
  if (opt_ != &::google::protobuf::internal::kEmptyString) {
    delete opt_;
  }
  if (this != default_instance_) {
  }
}

void Frame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Frame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Frame_descriptor_;
}

const Frame& Frame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  return *default_instance_;
}

Frame* Frame::default_instance_ = NULL;

Frame* Frame::New() const {
  return new Frame;
}

void Frame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    pos_ = GOOGLE_LONGLONG(0);
    if (has_opt()) {
      if (opt_ != &::google::protobuf::internal::kEmptyString) {
        opt_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Frame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Frame.FrameType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Frame_FrameType_IsValid(value)) {
            set_type(static_cast< ::Frame_FrameType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_pos;
        break;
      }

      // optional int64 pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &pos_)));
          set_has_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_opt;
        break;
      }

      // optional string opt = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_opt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_opt()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->opt().data(), this->opt().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Frame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Frame.FrameType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional int64 pos = 2;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->pos(), output);
  }

  // optional string opt = 3;
  if (has_opt()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->opt().data(), this->opt().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->opt(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Frame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Frame.FrameType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional int64 pos = 2;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->pos(), target);
  }

  // optional string opt = 3;
  if (has_opt()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->opt().data(), this->opt().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->opt(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Frame::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Frame.FrameType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional int64 pos = 2;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->pos());
    }

    // optional string opt = 3;
    if (has_opt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->opt());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Frame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Frame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Frame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Frame::MergeFrom(const Frame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_pos()) {
      set_pos(from.pos());
    }
    if (from.has_opt()) {
      set_opt(from.opt());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Frame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Frame::CopyFrom(const Frame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame::IsInitialized() const {

  return true;
}

void Frame::Swap(Frame* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(pos_, other->pos_);
    std::swap(opt_, other->opt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Frame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Frame_descriptor_;
  metadata.reflection = Frame_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Backtrace::kFramesFieldNumber;
#endif  // !_MSC_VER

Backtrace::Backtrace()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Backtrace::InitAsDefaultInstance() {
}

Backtrace::Backtrace(const Backtrace& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Backtrace::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Backtrace::~Backtrace() {
  SharedDtor();
}

void Backtrace::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Backtrace::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Backtrace::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Backtrace_descriptor_;
}

const Backtrace& Backtrace::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  return *default_instance_;
}

Backtrace* Backtrace::default_instance_ = NULL;

Backtrace* Backtrace::New() const {
  return new Backtrace;
}

void Backtrace::Clear() {
  frames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Backtrace::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Frame frames = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_frames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_frames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_frames;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Backtrace::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Frame frames = 1;
  for (int i = 0; i < this->frames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->frames(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Backtrace::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Frame frames = 1;
  for (int i = 0; i < this->frames_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->frames(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Backtrace::ByteSize() const {
  int total_size = 0;

  // repeated .Frame frames = 1;
  total_size += 1 * this->frames_size();
  for (int i = 0; i < this->frames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->frames(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Backtrace::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Backtrace* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Backtrace*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Backtrace::MergeFrom(const Backtrace& from) {
  GOOGLE_CHECK_NE(&from, this);
  frames_.MergeFrom(from.frames_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Backtrace::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Backtrace::CopyFrom(const Backtrace& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backtrace::IsInitialized() const {

  return true;
}

void Backtrace::Swap(Backtrace* other) {
  if (other != this) {
    frames_.Swap(&other->frames_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Backtrace::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Backtrace_descriptor_;
  metadata.reflection = Backtrace_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Response_ResponseType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Response_ResponseType_descriptor_;
}
bool Response_ResponseType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Response_ResponseType Response::SUCCESS_ATOM;
const Response_ResponseType Response::SUCCESS_SEQUENCE;
const Response_ResponseType Response::SUCCESS_PARTIAL;
const Response_ResponseType Response::WAIT_COMPLETE;
const Response_ResponseType Response::SERVER_INFO;
const Response_ResponseType Response::CLIENT_ERROR;
const Response_ResponseType Response::COMPILE_ERROR;
const Response_ResponseType Response::RUNTIME_ERROR;
const Response_ResponseType Response::ResponseType_MIN;
const Response_ResponseType Response::ResponseType_MAX;
const int Response::ResponseType_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Response_ErrorType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Response_ErrorType_descriptor_;
}
bool Response_ErrorType_IsValid(int value) {
  switch(value) {
    case 1000000:
    case 2000000:
    case 3000000:
    case 3100000:
    case 4100000:
    case 4200000:
    case 5000000:
    case 6000000:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Response_ErrorType Response::INTERNAL;
const Response_ErrorType Response::RESOURCE_LIMIT;
const Response_ErrorType Response::QUERY_LOGIC;
const Response_ErrorType Response::NON_EXISTENCE;
const Response_ErrorType Response::OP_FAILED;
const Response_ErrorType Response::OP_INDETERMINATE;
const Response_ErrorType Response::USER;
const Response_ErrorType Response::PERMISSION_ERROR;
const Response_ErrorType Response::ErrorType_MIN;
const Response_ErrorType Response::ErrorType_MAX;
const int Response::ErrorType_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Response_ResponseNote_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Response_ResponseNote_descriptor_;
}
bool Response_ResponseNote_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Response_ResponseNote Response::SEQUENCE_FEED;
const Response_ResponseNote Response::ATOM_FEED;
const Response_ResponseNote Response::ORDER_BY_LIMIT_FEED;
const Response_ResponseNote Response::UNIONED_FEED;
const Response_ResponseNote Response::INCLUDES_STATES;
const Response_ResponseNote Response::ResponseNote_MIN;
const Response_ResponseNote Response::ResponseNote_MAX;
const int Response::ResponseNote_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Response::kTypeFieldNumber;
const int Response::kErrorTypeFieldNumber;
const int Response::kNotesFieldNumber;
const int Response::kTokenFieldNumber;
const int Response::kResponseFieldNumber;
const int Response::kBacktraceFieldNumber;
const int Response::kProfileFieldNumber;
#endif  // !_MSC_VER

Response::Response()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Response::InitAsDefaultInstance() {
  backtrace_ = const_cast< ::Backtrace*>(&::Backtrace::default_instance());
  profile_ = const_cast< ::Datum*>(&::Datum::default_instance());
}

Response::Response(const Response& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Response::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  error_type_ = 1000000;
  token_ = GOOGLE_LONGLONG(0);
  backtrace_ = NULL;
  profile_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Response::~Response() {
  SharedDtor();
}

void Response::SharedDtor() {
  if (this != default_instance_) {
    delete backtrace_;
    delete profile_;
  }
}

void Response::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Response::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Response_descriptor_;
}

const Response& Response::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  return *default_instance_;
}

Response* Response::default_instance_ = NULL;

Response* Response::New() const {
  return new Response;
}

void Response::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    error_type_ = 1000000;
    token_ = GOOGLE_LONGLONG(0);
    if (has_backtrace()) {
      if (backtrace_ != NULL) backtrace_->::Backtrace::Clear();
    }
    if (has_profile()) {
      if (profile_ != NULL) profile_->::Datum::Clear();
    }
  }
  notes_.Clear();
  response_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Response::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Response.ResponseType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Response_ResponseType_IsValid(value)) {
            set_type(static_cast< ::Response_ResponseType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_token;
        break;
      }

      // optional int64 token = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_token:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &token_)));
          set_has_token();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_response;
        break;
      }

      // repeated .Datum response = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_response()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_response;
        if (input->ExpectTag(34)) goto parse_backtrace;
        break;
      }

      // optional .Backtrace backtrace = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_backtrace:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_backtrace()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_profile;
        break;
      }

      // optional .Datum profile = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_profile:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_profile()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_notes;
        break;
      }

      // repeated .Response.ResponseNote notes = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_notes:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Response_ResponseNote_IsValid(value)) {
            add_notes(static_cast< ::Response_ResponseNote >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline(
                 input,
                 &::Response_ResponseNote_IsValid,
                 this->mutable_notes())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_notes;
        if (input->ExpectTag(56)) goto parse_error_type;
        break;
      }

      // optional .Response.ErrorType error_type = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_error_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Response_ErrorType_IsValid(value)) {
            set_error_type(static_cast< ::Response_ErrorType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Response::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Response.ResponseType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional int64 token = 2;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->token(), output);
  }

  // repeated .Datum response = 3;
  for (int i = 0; i < this->response_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->response(i), output);
  }

  // optional .Backtrace backtrace = 4;
  if (has_backtrace()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->backtrace(), output);
  }

  // optional .Datum profile = 5;
  if (has_profile()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->profile(), output);
  }

  // repeated .Response.ResponseNote notes = 6;
  for (int i = 0; i < this->notes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->notes(i), output);
  }

  // optional .Response.ErrorType error_type = 7;
  if (has_error_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->error_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Response::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Response.ResponseType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional int64 token = 2;
  if (has_token()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->token(), target);
  }

  // repeated .Datum response = 3;
  for (int i = 0; i < this->response_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->response(i), target);
  }

  // optional .Backtrace backtrace = 4;
  if (has_backtrace()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->backtrace(), target);
  }

  // optional .Datum profile = 5;
  if (has_profile()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->profile(), target);
  }

  // repeated .Response.ResponseNote notes = 6;
  for (int i = 0; i < this->notes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->notes(i), target);
  }

  // optional .Response.ErrorType error_type = 7;
  if (has_error_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->error_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Response::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Response.ResponseType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .Response.ErrorType error_type = 7;
    if (has_error_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error_type());
    }

    // optional int64 token = 2;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->token());
    }

    // optional .Backtrace backtrace = 4;
    if (has_backtrace()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->backtrace());
    }

    // optional .Datum profile = 5;
    if (has_profile()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->profile());
    }

  }
  // repeated .Response.ResponseNote notes = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->notes_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->notes(i));
    }
    total_size += 1 * this->notes_size() + data_size;
  }

  // repeated .Datum response = 3;
  total_size += 1 * this->response_size();
  for (int i = 0; i < this->response_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->response(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Response::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Response* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Response*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Response::MergeFrom(const Response& from) {
  GOOGLE_CHECK_NE(&from, this);
  notes_.MergeFrom(from.notes_);
  response_.MergeFrom(from.response_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_error_type()) {
      set_error_type(from.error_type());
    }
    if (from.has_token()) {
      set_token(from.token());
    }
    if (from.has_backtrace()) {
      mutable_backtrace()->::Backtrace::MergeFrom(from.backtrace());
    }
    if (from.has_profile()) {
      mutable_profile()->::Datum::MergeFrom(from.profile());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Response::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Response::CopyFrom(const Response& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Response::IsInitialized() const {

  return true;
}

void Response::Swap(Response* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(error_type_, other->error_type_);
    notes_.Swap(&other->notes_);
    std::swap(token_, other->token_);
    response_.Swap(&other->response_);
    std::swap(backtrace_, other->backtrace_);
    std::swap(profile_, other->profile_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Response::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Response_descriptor_;
  metadata.reflection = Response_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Datum_DatumType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Datum_DatumType_descriptor_;
}
bool Datum_DatumType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Datum_DatumType Datum::R_NULL;
const Datum_DatumType Datum::R_BOOL;
const Datum_DatumType Datum::R_NUM;
const Datum_DatumType Datum::R_STR;
const Datum_DatumType Datum::R_ARRAY;
const Datum_DatumType Datum::R_OBJECT;
const Datum_DatumType Datum::R_JSON;
const Datum_DatumType Datum::DatumType_MIN;
const Datum_DatumType Datum::DatumType_MAX;
const int Datum::DatumType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Datum_AssocPair::kKeyFieldNumber;
const int Datum_AssocPair::kValFieldNumber;
#endif  // !_MSC_VER

Datum_AssocPair::Datum_AssocPair()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Datum_AssocPair::InitAsDefaultInstance() {
  val_ = const_cast< ::Datum*>(&::Datum::default_instance());
}

Datum_AssocPair::Datum_AssocPair(const Datum_AssocPair& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Datum_AssocPair::SharedCtor() {
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  val_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Datum_AssocPair::~Datum_AssocPair() {
  SharedDtor();
}

void Datum_AssocPair::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (this != default_instance_) {
    delete val_;
  }
}

void Datum_AssocPair::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Datum_AssocPair::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Datum_AssocPair_descriptor_;
}

const Datum_AssocPair& Datum_AssocPair::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  return *default_instance_;
}

Datum_AssocPair* Datum_AssocPair::default_instance_ = NULL;

Datum_AssocPair* Datum_AssocPair::New() const {
  return new Datum_AssocPair;
}

void Datum_AssocPair::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
    if (has_val()) {
      if (val_ != NULL) val_->::Datum::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Datum_AssocPair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_val;
        break;
      }

      // optional .Datum val = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_val:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_val()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Datum_AssocPair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->key(), output);
  }

  // optional .Datum val = 2;
  if (has_val()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->val(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Datum_AssocPair::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }

  // optional .Datum val = 2;
  if (has_val()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->val(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Datum_AssocPair::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

    // optional .Datum val = 2;
    if (has_val()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->val());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Datum_AssocPair::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Datum_AssocPair* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Datum_AssocPair*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Datum_AssocPair::MergeFrom(const Datum_AssocPair& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_val()) {
      mutable_val()->::Datum::MergeFrom(from.val());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Datum_AssocPair::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Datum_AssocPair::CopyFrom(const Datum_AssocPair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Datum_AssocPair::IsInitialized() const {

  return true;
}

void Datum_AssocPair::Swap(Datum_AssocPair* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(val_, other->val_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Datum_AssocPair::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Datum_AssocPair_descriptor_;
  metadata.reflection = Datum_AssocPair_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Datum::kTypeFieldNumber;
const int Datum::kRBoolFieldNumber;
const int Datum::kRNumFieldNumber;
const int Datum::kRStrFieldNumber;
const int Datum::kRArrayFieldNumber;
const int Datum::kRObjectFieldNumber;
#endif  // !_MSC_VER

Datum::Datum()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Datum::InitAsDefaultInstance() {
}

Datum::Datum(const Datum& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Datum::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  r_bool_ = false;
  r_num_ = 0;
  r_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Datum::~Datum() {
  SharedDtor();
}

void Datum::SharedDtor() {
  if (r_str_ != &::google::protobuf::internal::kEmptyString) {
    delete r_str_;
  }
  if (this != default_instance_) {
  }
}

void Datum::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Datum::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Datum_descriptor_;
}

const Datum& Datum::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  return *default_instance_;
}

Datum* Datum::default_instance_ = NULL;

Datum* Datum::New() const {
  return new Datum;
}

void Datum::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    r_bool_ = false;
    r_num_ = 0;
    if (has_r_str()) {
      if (r_str_ != &::google::protobuf::internal::kEmptyString) {
        r_str_->clear();
      }
    }
  }
  r_array_.Clear();
  r_object_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Datum::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Datum.DatumType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Datum_DatumType_IsValid(value)) {
            set_type(static_cast< ::Datum_DatumType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_r_bool;
        break;
      }

      // optional bool r_bool = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_r_bool:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &r_bool_)));
          set_has_r_bool();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_r_num;
        break;
      }

      // optional double r_num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_r_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &r_num_)));
          set_has_r_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_r_str;
        break;
      }

      // optional string r_str = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_r_str:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_r_str()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->r_str().data(), this->r_str().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_r_array;
        break;
      }

      // repeated .Datum r_array = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_r_array:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_r_array()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_r_array;
        if (input->ExpectTag(50)) goto parse_r_object;
        break;
      }

      // repeated .Datum.AssocPair r_object = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_r_object:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_r_object()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_r_object;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Datum::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Datum.DatumType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional bool r_bool = 2;
  if (has_r_bool()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->r_bool(), output);
  }

  // optional double r_num = 3;
  if (has_r_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->r_num(), output);
  }

  // optional string r_str = 4;
  if (has_r_str()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->r_str().data(), this->r_str().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->r_str(), output);
  }

  // repeated .Datum r_array = 5;
  for (int i = 0; i < this->r_array_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->r_array(i), output);
  }

  // repeated .Datum.AssocPair r_object = 6;
  for (int i = 0; i < this->r_object_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->r_object(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Datum::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Datum.DatumType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional bool r_bool = 2;
  if (has_r_bool()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->r_bool(), target);
  }

  // optional double r_num = 3;
  if (has_r_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->r_num(), target);
  }

  // optional string r_str = 4;
  if (has_r_str()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->r_str().data(), this->r_str().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->r_str(), target);
  }

  // repeated .Datum r_array = 5;
  for (int i = 0; i < this->r_array_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->r_array(i), target);
  }

  // repeated .Datum.AssocPair r_object = 6;
  for (int i = 0; i < this->r_object_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->r_object(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Datum::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Datum.DatumType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional bool r_bool = 2;
    if (has_r_bool()) {
      total_size += 1 + 1;
    }

    // optional double r_num = 3;
    if (has_r_num()) {
      total_size += 1 + 8;
    }

    // optional string r_str = 4;
    if (has_r_str()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->r_str());
    }

  }
  // repeated .Datum r_array = 5;
  total_size += 1 * this->r_array_size();
  for (int i = 0; i < this->r_array_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->r_array(i));
  }

  // repeated .Datum.AssocPair r_object = 6;
  total_size += 1 * this->r_object_size();
  for (int i = 0; i < this->r_object_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->r_object(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Datum::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Datum* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Datum*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Datum::MergeFrom(const Datum& from) {
  GOOGLE_CHECK_NE(&from, this);
  r_array_.MergeFrom(from.r_array_);
  r_object_.MergeFrom(from.r_object_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_r_bool()) {
      set_r_bool(from.r_bool());
    }
    if (from.has_r_num()) {
      set_r_num(from.r_num());
    }
    if (from.has_r_str()) {
      set_r_str(from.r_str());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Datum::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Datum::CopyFrom(const Datum& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Datum::IsInitialized() const {

  return true;
}

void Datum::Swap(Datum* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(r_bool_, other->r_bool_);
    std::swap(r_num_, other->r_num_);
    std::swap(r_str_, other->r_str_);
    r_array_.Swap(&other->r_array_);
    r_object_.Swap(&other->r_object_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Datum::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Datum_descriptor_;
  metadata.reflection = Datum_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Term_TermType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Term_TermType_descriptor_;
}
bool Term_TermType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:
    case 160:
    case 161:
    case 162:
    case 163:
    case 164:
    case 165:
    case 166:
    case 167:
    case 168:
    case 169:
    case 170:
    case 171:
    case 172:
    case 173:
    case 174:
    case 175:
    case 176:
    case 177:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 184:
    case 185:
    case 186:
    case 187:
    case 188:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Term_TermType Term::DATUM;
const Term_TermType Term::MAKE_ARRAY;
const Term_TermType Term::MAKE_OBJ;
const Term_TermType Term::VAR;
const Term_TermType Term::JAVASCRIPT;
const Term_TermType Term::UUID;
const Term_TermType Term::HTTP;
const Term_TermType Term::ERROR;
const Term_TermType Term::IMPLICIT_VAR;
const Term_TermType Term::DB;
const Term_TermType Term::TABLE;
const Term_TermType Term::GET;
const Term_TermType Term::GET_ALL;
const Term_TermType Term::EQ;
const Term_TermType Term::NE;
const Term_TermType Term::LT;
const Term_TermType Term::LE;
const Term_TermType Term::GT;
const Term_TermType Term::GE;
const Term_TermType Term::NOT;
const Term_TermType Term::ADD;
const Term_TermType Term::SUB;
const Term_TermType Term::MUL;
const Term_TermType Term::DIV;
const Term_TermType Term::MOD;
const Term_TermType Term::FLOOR;
const Term_TermType Term::CEIL;
const Term_TermType Term::ROUND;
const Term_TermType Term::APPEND;
const Term_TermType Term::PREPEND;
const Term_TermType Term::DIFFERENCE;
const Term_TermType Term::SET_INSERT;
const Term_TermType Term::SET_INTERSECTION;
const Term_TermType Term::SET_UNION;
const Term_TermType Term::SET_DIFFERENCE;
const Term_TermType Term::SLICE;
const Term_TermType Term::SKIP;
const Term_TermType Term::LIMIT;
const Term_TermType Term::OFFSETS_OF;
const Term_TermType Term::CONTAINS;
const Term_TermType Term::GET_FIELD;
const Term_TermType Term::KEYS;
const Term_TermType Term::VALUES;
const Term_TermType Term::OBJECT;
const Term_TermType Term::HAS_FIELDS;
const Term_TermType Term::WITH_FIELDS;
const Term_TermType Term::PLUCK;
const Term_TermType Term::WITHOUT;
const Term_TermType Term::MERGE;
const Term_TermType Term::BETWEEN_DEPRECATED;
const Term_TermType Term::BETWEEN;
const Term_TermType Term::REDUCE;
const Term_TermType Term::MAP;
const Term_TermType Term::FOLD;
const Term_TermType Term::FILTER;
const Term_TermType Term::CONCAT_MAP;
const Term_TermType Term::ORDER_BY;
const Term_TermType Term::DISTINCT;
const Term_TermType Term::COUNT;
const Term_TermType Term::IS_EMPTY;
const Term_TermType Term::UNION;
const Term_TermType Term::NTH;
const Term_TermType Term::BRACKET;
const Term_TermType Term::INNER_JOIN;
const Term_TermType Term::OUTER_JOIN;
const Term_TermType Term::EQ_JOIN;
const Term_TermType Term::ZIP;
const Term_TermType Term::RANGE;
const Term_TermType Term::INSERT_AT;
const Term_TermType Term::DELETE_AT;
const Term_TermType Term::CHANGE_AT;
const Term_TermType Term::SPLICE_AT;
const Term_TermType Term::COERCE_TO;
const Term_TermType Term::TYPE_OF;
const Term_TermType Term::UPDATE;
const Term_TermType Term::DELETE;
const Term_TermType Term::REPLACE;
const Term_TermType Term::INSERT;
const Term_TermType Term::DB_CREATE;
const Term_TermType Term::DB_DROP;
const Term_TermType Term::DB_LIST;
const Term_TermType Term::TABLE_CREATE;
const Term_TermType Term::TABLE_DROP;
const Term_TermType Term::TABLE_LIST;
const Term_TermType Term::CONFIG;
const Term_TermType Term::STATUS;
const Term_TermType Term::WAIT;
const Term_TermType Term::RECONFIGURE;
const Term_TermType Term::REBALANCE;
const Term_TermType Term::SYNC;
const Term_TermType Term::GRANT;
const Term_TermType Term::INDEX_CREATE;
const Term_TermType Term::INDEX_DROP;
const Term_TermType Term::INDEX_LIST;
const Term_TermType Term::INDEX_STATUS;
const Term_TermType Term::INDEX_WAIT;
const Term_TermType Term::INDEX_RENAME;
const Term_TermType Term::FUNCALL;
const Term_TermType Term::BRANCH;
const Term_TermType Term::OR;
const Term_TermType Term::AND;
const Term_TermType Term::FOR_EACH;
const Term_TermType Term::FUNC;
const Term_TermType Term::ASC;
const Term_TermType Term::DESC;
const Term_TermType Term::INFO;
const Term_TermType Term::MATCH;
const Term_TermType Term::UPCASE;
const Term_TermType Term::DOWNCASE;
const Term_TermType Term::SAMPLE;
const Term_TermType Term::DEFAULT;
const Term_TermType Term::JSON;
const Term_TermType Term::TO_JSON_STRING;
const Term_TermType Term::ISO8601;
const Term_TermType Term::TO_ISO8601;
const Term_TermType Term::EPOCH_TIME;
const Term_TermType Term::TO_EPOCH_TIME;
const Term_TermType Term::NOW;
const Term_TermType Term::IN_TIMEZONE;
const Term_TermType Term::DURING;
const Term_TermType Term::DATE;
const Term_TermType Term::TIME_OF_DAY;
const Term_TermType Term::TIMEZONE;
const Term_TermType Term::YEAR;
const Term_TermType Term::MONTH;
const Term_TermType Term::DAY;
const Term_TermType Term::DAY_OF_WEEK;
const Term_TermType Term::DAY_OF_YEAR;
const Term_TermType Term::HOURS;
const Term_TermType Term::MINUTES;
const Term_TermType Term::SECONDS;
const Term_TermType Term::TIME;
const Term_TermType Term::MONDAY;
const Term_TermType Term::TUESDAY;
const Term_TermType Term::WEDNESDAY;
const Term_TermType Term::THURSDAY;
const Term_TermType Term::FRIDAY;
const Term_TermType Term::SATURDAY;
const Term_TermType Term::SUNDAY;
const Term_TermType Term::JANUARY;
const Term_TermType Term::FEBRUARY;
const Term_TermType Term::MARCH;
const Term_TermType Term::APRIL;
const Term_TermType Term::MAY;
const Term_TermType Term::JUNE;
const Term_TermType Term::JULY;
const Term_TermType Term::AUGUST;
const Term_TermType Term::SEPTEMBER;
const Term_TermType Term::OCTOBER;
const Term_TermType Term::NOVEMBER;
const Term_TermType Term::DECEMBER;
const Term_TermType Term::LITERAL;
const Term_TermType Term::GROUP;
const Term_TermType Term::SUM;
const Term_TermType Term::AVG;
const Term_TermType Term::MIN;
const Term_TermType Term::MAX;
const Term_TermType Term::SPLIT;
const Term_TermType Term::UNGROUP;
const Term_TermType Term::RANDOM;
const Term_TermType Term::CHANGES;
const Term_TermType Term::ARGS;
const Term_TermType Term::BINARY;
const Term_TermType Term::GEOJSON;
const Term_TermType Term::TO_GEOJSON;
const Term_TermType Term::POINT;
const Term_TermType Term::LINE;
const Term_TermType Term::POLYGON;
const Term_TermType Term::DISTANCE;
const Term_TermType Term::INTERSECTS;
const Term_TermType Term::INCLUDES;
const Term_TermType Term::CIRCLE;
const Term_TermType Term::GET_INTERSECTING;
const Term_TermType Term::FILL;
const Term_TermType Term::GET_NEAREST;
const Term_TermType Term::POLYGON_SUB;
const Term_TermType Term::MINVAL;
const Term_TermType Term::MAXVAL;
const Term_TermType Term::TermType_MIN;
const Term_TermType Term::TermType_MAX;
const int Term::TermType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Term_AssocPair::kKeyFieldNumber;
const int Term_AssocPair::kValFieldNumber;
#endif  // !_MSC_VER

Term_AssocPair::Term_AssocPair()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Term_AssocPair::InitAsDefaultInstance() {
  val_ = const_cast< ::Term*>(&::Term::default_instance());
}

Term_AssocPair::Term_AssocPair(const Term_AssocPair& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Term_AssocPair::SharedCtor() {
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  val_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Term_AssocPair::~Term_AssocPair() {
  SharedDtor();
}

void Term_AssocPair::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (this != default_instance_) {
    delete val_;
  }
}

void Term_AssocPair::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Term_AssocPair::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Term_AssocPair_descriptor_;
}

const Term_AssocPair& Term_AssocPair::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  return *default_instance_;
}

Term_AssocPair* Term_AssocPair::default_instance_ = NULL;

Term_AssocPair* Term_AssocPair::New() const {
  return new Term_AssocPair;
}

void Term_AssocPair::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
    if (has_val()) {
      if (val_ != NULL) val_->::Term::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Term_AssocPair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_val;
        break;
      }

      // optional .Term val = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_val:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_val()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Term_AssocPair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->key(), output);
  }

  // optional .Term val = 2;
  if (has_val()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->val(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Term_AssocPair::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }

  // optional .Term val = 2;
  if (has_val()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->val(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Term_AssocPair::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

    // optional .Term val = 2;
    if (has_val()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->val());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Term_AssocPair::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Term_AssocPair* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Term_AssocPair*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Term_AssocPair::MergeFrom(const Term_AssocPair& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_val()) {
      mutable_val()->::Term::MergeFrom(from.val());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Term_AssocPair::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Term_AssocPair::CopyFrom(const Term_AssocPair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Term_AssocPair::IsInitialized() const {

  return true;
}

void Term_AssocPair::Swap(Term_AssocPair* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(val_, other->val_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Term_AssocPair::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Term_AssocPair_descriptor_;
  metadata.reflection = Term_AssocPair_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Term::kTypeFieldNumber;
const int Term::kDatumFieldNumber;
const int Term::kArgsFieldNumber;
const int Term::kOptargsFieldNumber;
#endif  // !_MSC_VER

Term::Term()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Term::InitAsDefaultInstance() {
  datum_ = const_cast< ::Datum*>(&::Datum::default_instance());
}

Term::Term(const Term& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Term::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  datum_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Term::~Term() {
  SharedDtor();
}

void Term::SharedDtor() {
  if (this != default_instance_) {
    delete datum_;
  }
}

void Term::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Term::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Term_descriptor_;
}

const Term& Term::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rdb_5fprotocol_2fql2_2eproto();
  return *default_instance_;
}

Term* Term::default_instance_ = NULL;

Term* Term::New() const {
  return new Term;
}

void Term::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_datum()) {
      if (datum_ != NULL) datum_->::Datum::Clear();
    }
  }
  args_.Clear();
  optargs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Term::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Term.TermType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Term_TermType_IsValid(value)) {
            set_type(static_cast< ::Term_TermType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_datum;
        break;
      }

      // optional .Datum datum = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_datum:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_datum()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_args;
        break;
      }

      // repeated .Term args = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_args()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_args;
        if (input->ExpectTag(34)) goto parse_optargs;
        break;
      }

      // repeated .Term.AssocPair optargs = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_optargs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_optargs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_optargs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Term::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Term.TermType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .Datum datum = 2;
  if (has_datum()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->datum(), output);
  }

  // repeated .Term args = 3;
  for (int i = 0; i < this->args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->args(i), output);
  }

  // repeated .Term.AssocPair optargs = 4;
  for (int i = 0; i < this->optargs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->optargs(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Term::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Term.TermType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .Datum datum = 2;
  if (has_datum()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->datum(), target);
  }

  // repeated .Term args = 3;
  for (int i = 0; i < this->args_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->args(i), target);
  }

  // repeated .Term.AssocPair optargs = 4;
  for (int i = 0; i < this->optargs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->optargs(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Term::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Term.TermType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .Datum datum = 2;
    if (has_datum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->datum());
    }

  }
  // repeated .Term args = 3;
  total_size += 1 * this->args_size();
  for (int i = 0; i < this->args_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->args(i));
  }

  // repeated .Term.AssocPair optargs = 4;
  total_size += 1 * this->optargs_size();
  for (int i = 0; i < this->optargs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->optargs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Term::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Term* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Term*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Term::MergeFrom(const Term& from) {
  GOOGLE_CHECK_NE(&from, this);
  args_.MergeFrom(from.args_);
  optargs_.MergeFrom(from.optargs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_datum()) {
      mutable_datum()->::Datum::MergeFrom(from.datum());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Term::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Term::CopyFrom(const Term& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Term::IsInitialized() const {

  return true;
}

void Term::Swap(Term* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(datum_, other->datum_);
    args_.Swap(&other->args_);
    optargs_.Swap(&other->optargs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Term::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Term_descriptor_;
  metadata.reflection = Term_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
